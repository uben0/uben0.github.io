<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Tutoriel Rust</title>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>
    <body>
<a href="index.html#c
21
" class="index-link">← retour</a>
<h1 id="méthodes">Méthodes</h1>
<p>Nous avons écrit précédemment les fonctions <code>deplace_point</code> et <code>air_cercle</code>, qui toutes deux sont logiquement liées aux types <code>Point</code> et <code>Cercle</code>. Il y a une façon de créer des fonctions associées avec le mot clé <code>impl</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Point <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> deplace(p<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Point<span class="op">,</span> dx<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span> dy<span class="op">:</span> <span class="dt">f64</span>) <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        p<span class="op">.</span>x <span class="op">+=</span> dx<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        p<span class="op">.</span>y <span class="op">+=</span> dy<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> p <span class="op">=</span> Point <span class="op">{</span> x<span class="op">:</span> <span class="dv">2.0</span><span class="op">,</span> y<span class="op">:</span> <span class="dv">3.0</span> <span class="op">};</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="pp">Point::</span>deplace(<span class="op">&amp;</span><span class="kw">mut</span> p<span class="op">,</span> <span class="dv">2.0</span><span class="op">,</span> <span class="dv">1.0</span>)<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> p)<span class="op">;</span></span></code></pre></div>
<pre><code>Point { x: 4.0, y: 4.0 }</code></pre>
<p>On voit que la fonction <code>deplace</code> est rangée dans une sorte de dossier nomé <code>Point::</code>.</p>
<h2 id="constructeur">Constructeur</h2>
<p>Il n’y a pas de constructeurs en Rust, mais par convention, pour construire un <code>type</code>, on lui associe une fonction nomée <code>new</code>, rien n’oblige à l’appeler comme ça, <code>new</code> n’est pas un mot clé, c’est juste une convention.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Point <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> new(x<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span> y<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> Point <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> p <span class="op">=</span> Point <span class="op">{</span> x<span class="op">:</span> x<span class="op">,</span> y<span class="op">:</span> y <span class="op">};</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span> p<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> deplace(p<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Point<span class="op">,</span> dx<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span> dy<span class="op">:</span> <span class="dt">f64</span>) <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        p<span class="op">.</span>x <span class="op">+=</span> dx<span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        p<span class="op">.</span>y <span class="op">+=</span> dy<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> p1 <span class="op">=</span> Point <span class="op">{</span> x<span class="op">:</span> <span class="dv">2.0</span><span class="op">,</span> y<span class="op">:</span> <span class="dv">3.0</span> <span class="op">};</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> p2 <span class="op">=</span> <span class="pp">Point::</span>new(<span class="dv">2.0</span><span class="op">,</span> <span class="dv">3.0</span>)<span class="op">;</span></span></code></pre></div>
<p>Les deux initialisations sont équivalantes, et ici la fonction <code>new</code> n’apporte pas une simplification notable, mais dans le cas de structures plus complexes, il vaut mieux avoir une fonction <code>new</code>.</p>
<h2 id="encapsulation">Encapsulation</h2>
<p>Rust n’est pas un langage orienté objet mais beaucoup de concepts de programmation orienté objets se retrouve dans Rust, comme le concept d’encapsulation qui consiste à rendre un type opaque et limiter son utilisation via des fonctions. Par exemple, ne pouvoir construire un type que en utilisant un constructeur. On vera plus tard comment encapsuler un type dans les règles de l’art. Pour l’instant nous n’avons pas les outils pour le faire.</p>
<h2 id="méthodes-1">Méthodes</h2>
<p>Ce serait pratique de pouvoir écrire <code>Point::deplace</code> comme si c’était une méthode de <code>Point</code> et pas juste une fonction associée.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> p <span class="op">=</span> <span class="pp">Point::</span>new(<span class="dv">2.0</span><span class="op">,</span> <span class="dv">3.0</span>)<span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>p<span class="op">.</span>deplace(<span class="dv">1.0</span><span class="op">,</span> <span class="dv">0.5</span>)<span class="op">;</span> <span class="co">// ERROR</span></span></code></pre></div>
<p>C’est possible, pour cela il suffit de modifier la définition de <code>deplace</code> en remplaçant le nom de la variable représentant l’objet par le mot clé <code>self</code> :</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> Point <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> deplace(<span class="kw">self</span><span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> Point<span class="op">,</span> dx<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span> dy<span class="op">:</span> <span class="dt">f64</span>) <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>x <span class="op">+=</span> dx<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">self</span><span class="op">.</span>y <span class="op">+=</span> dy<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>De cette façon, le compilateur comprend que l’on souhaite que la fonction <code>deplace</code> puisse être utilisée comme une méthode.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> p <span class="op">=</span> <span class="pp">Point::</span>new(<span class="dv">2.0</span><span class="op">,</span> <span class="dv">3.0</span>)<span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>p<span class="op">.</span>deplace(<span class="dv">1.0</span><span class="op">,</span> <span class="dv">0.5</span>)<span class="op">;</span> <span class="co">// OK</span></span></code></pre></div>
<p>Ajoutons une méthode qui retourne la distance avec un autre point:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> distance(<span class="kw">self</span><span class="op">:</span> <span class="op">&amp;</span>Point<span class="op">,</span> p<span class="op">:</span> <span class="op">&amp;</span>Point) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> dx <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>x <span class="op">-</span> p<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> dy <span class="op">=</span> <span class="kw">self</span><span class="op">.</span>y <span class="op">-</span> p<span class="op">.</span>y<span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">return</span> <span class="dt">f64</span><span class="pp">::</span>sqrt(dx <span class="op">*</span> dx <span class="op">+</span> dy <span class="op">*</span> dy)<span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a <span class="op">=</span> <span class="pp">Point::</span>new(<span class="dv">2.0</span><span class="op">,</span> <span class="dv">3.0</span>)<span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> b <span class="op">=</span> <span class="pp">Point::</span>new(<span class="dv">10.0</span><span class="op">,</span> <span class="dv">7.0</span>)<span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> d <span class="op">=</span> a<span class="op">.</span>distance(<span class="op">&amp;</span>b)<span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> d)<span class="op">;</span></span></code></pre></div>
<pre><code>8.94427190999916</code></pre>
    </body>
</html>